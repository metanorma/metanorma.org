---
layout: develop-docs
---

= Localization

Metanorma allows for documents to be authored in any language.

Localizing predefined text that appears in document output
(labels such as "`Table`", "`Foreword`", predefined text for Normative References, etc.)
for each language apart from English is done using a YAML template file.

== Supported languages

Metanorma has predefined language templates for English, Chinese (Simplified) and French.
The Chinese (Simplified) template localizes punctuation and spacing,
mapping them away from the default Latin punctuation used normally in Metanorma.

== Adding a language

You can add a new language by creating a YAML template file with predefined text.
Document authors will need to link to that file via `:i18nyaml:` document attribute
(see link:/author/topics/languages[Languages] in Author's documentation).

See https://github.com/metanorma/metanorma-iso/blob/main/spec/examples/english.yaml[sample YAML file for English],
where "Foreword" is replaced with "Frontispiece",
under `metanorma-iso` repository's examples directory.

[TIP]
====
A good way to start is to take that sample template and customize it for your language.
====

== Localizing resulting output

[TIP]
.Summary
====
* Copy the `lib/isodoc/i18n-en.yaml` file from the `isodoc` gem to your gem.
* Edit the right-hand text in the file.
* Give the file location as the `i18nyaml` document attribute in any files you wish to use your localization.
====

Every piece of text generated by the toolset instead of the author is looked up in an internationalization file; that means that if the language setting for the document changes, and there is an internationalization file for that language, all output is localized to that language. Of the existing gems, `metanorma-gb` is localized in this way for English and Chinese, and `metanorma-iso` is localized for English, French and Chinese.

The localization files are http://yaml.org[YAML] files stores in `lib/isodoc/`, named `i18n-{languagecode}.yaml`. (In the case of Chinese, the script code is added to the filename: `i18n-zh-Hans.yaml`.) Most localized text are direct mappings from English metalanguage to the target language (including English itself); there are also instances of hashes in the YAML files. Most localization text consists of one- or two-word labels, such as "Figure" or "Annex"; some predefined text is also included in the localization text, such as the ISO text describing the use of external sources in Terms and Definitions.

Localization is mostly used for translation purposes, but they can also be used to customize the rendering of particular labels in English. For example, the default English label for a first-level supplementary section is "Annex", reflecting ISO practice; but in the `metanorma-m3aawg` gem (`/lib/isodoc/m3aawg/base_convert.rb`), this label is overruled in code to be "Appendix" instead.

The YAML files are read into the `IsoDoc` classes through the `i18n_init()` method of `IsoDoc::...::HtmlConvert` and `Isodoc::...::WordConvert`. The localization equivalents for the nominated language are read from the corresponding YAML file into the `@labels` hash. The base IsoDoc instance of `i18n_init()` also assigns an instance variable for each label (e.g. `@annex_lbl` for English "Annex"). These instance variables are used to generate all automated text in the IsoDoc classes.

All current gems inherit their localization files from the base `isodoc` gem.
The local `i18n_init()` instance can overwrite individual labels in code,
or they can read in a local additional YAML file for the same language.
If you are implementing a completely new language, you will need to replace the base `i18n_init()`
method rather than inheriting from it, to ensure that the local YAML files are read in.

The foregoing describes how to incorporate localization into your gem on a permanent basis; but the toolset also allows you to nominate a YAML localization file just for the current document. In AsciiDoc, the YAML file is nominated as the `:i18nyaml:` document attribute; for IsoDoc, it is passed in as the `i18nyaml` hash attribute to the initialization method. You will still need to access the base IsoDoc YAML instances, to make sure that all necessary labels are given in your YAML document.

In the case of cross-reference labels (`clause`, `table`, `figure`, etc.), the corresponding text is by default entered capitalized, and is assumed to retain capital case throughout. If the text is lowercase, Metanorma will attempt to impose correct capitalisation for instances at the start of blocks and sentences, but it may get it wrong. To override such capitalisation, you can use the the flags `capital%`
or `lowercase%` as the content of the cross-reference, to force that casing on the
cross-reference [added in https://github.com/metanorma/isodoc/releases/tag/v1.0.28].

=== Example internationalization code

* `metanorma-mpfa/lib/isodoc/mpfa/i18n-en.yaml`: customization of clause label in YAML

[source]
--
clause: Paragraph
--

* `metanorma-m3aawg/lib/isodoc/m3aawg/m3dhtmlconvert.rb`: customization of annex label as class variable

[source,ruby]
--
def i18n_init(lang, script)
  super
  @annex_lbl = "Appendix"
end
--

* `metanorma-gb/lib/isodoc/gb/gbhtmlconvert.rb`: code to read in internationalization YAML templates (merges superclass `@labels` map, derived from the parent `Isodoc::HtmlConvert` class, with the labels read in from the GB-specific YAML templates.)

[source,ruby]
----
def i18n_init(lang, script)
  super
  file_name = if lang == "en"
                "i18n-en.yaml"
              elsif lang == "zh" && script == "Hant"
                "i18n-zh-Hant.yaml"
              else
                "i18n-zh-Hans.yaml"
              end
  y = YAML.load_file(File.join(File.dirname(__FILE__), file_name))
  @labels = @labels.merge(y)
end
----

== Grammatical information

Grammatical information about words is needed to generate the correct output. This is stored under `inflection` in the YAML file,
and it takes two forms:

* Giving the different numbers of the word, so that plurals can be generated correctly
* Giving other grammatical information where necessary, under `grammar`. This is mostly used so that templated text can use the
right gender associated with the word.

So the Russian YAML file includes the following information for Глава "chapter" and издание "edition":

[source,yaml]
----
  Глава:
    sg: Глава
    pl: Главы
  издание:
    grammar:
      gender: n
----

"Chapter" is given in its singular and plural; the plural is used to auto-generate references to multiple chapters (e.g. _Chapters 3-7_,
Главы 3–7). "Edition" is given as being neuter gender, so that any adjectives autogenerated with (e.g. "third edition") can appear in the
correct gender (neuter третье издание, not masculine третий издание)


== Templating syntax

* The YAML file can use parameters to pass arbitrary variables in for processing; these are indicated as `%` or `%1`, `%2`, `%3`... 
The interpretation of those parameters is hardcoded for those templated variables. For example, in `termnote: Note % to entry`, `%` is
hard-coded to pass in the number of the term note.
* The YAML file can use Liquid to pass named variables, and process them using defined filters. For example, in 
`"{{ var1 | ordinal_word: 'edition', 'acc.sg' }} издание"`, Metanorma is extracted to convert the number in `var1` passed to the template
into an ordinal number in the target language, and further (1) look up the inflectional categories for the word "edition" (which, in Russian,
is neuter), and (2) add to it the inflectional information in the second argument (we want the accusative singular of the Russian ordinal).
As of this writing, ordinals of numbers (e.g. "third", "третье") are the only such Liquid template defined.
* Other entries in the YAML file can be invoked through 
`#{ self["path-to-entry"] }` [added in https://github.com/metanorma/isodoc-18n/releases/tag/v1.4.1]. 
For example, the enumeration comma for Japanese is different in different flavours, and can be defined specific to a flavour or even a document.
An entry like `"%1#{ self["punct"]["enum-comma"]%2"` allows Metanorma to retrieve whatever the current definition of the enumeration comma is,
and use it elsewhere in the configuration.
